{
 "id": "368829",
 "text": "Programming paradigms are a way of grouping programming languages by what they do. Languages can be in more than one paradigm. Some paradigms look at the way the code is run, such as allowing side effects, or having to do things in a certain order. Other paradigms look at the way that code is grouped, such as putting code into one or two pieces (or instead, many small pieces). Some other paradigms look at the order and pieces that make the program the way it is. There are two main groups of paradigms, imperative and declarative. A language can be both at the same time.NÃ¸rmark, Kurt. Overview of the four main programming paradigms. Aalborg University, 9 May 2011. Retrieved 22 September 2012. == Imperative programming == In imperative programs, programmers give the computer a set of ordered steps that need to be done in order to do something. If someone wanted the computer to draw a cat face, they might give directions like \"Draw a circle here, draw two smaller circles there, draw two triangles on top\" and so on. Imperative programs sometimes have a lot of side effects. There are two major imperative paradigms, and a lot of the time a language will have both: *StructuredThe computer is given directions that are always in a certain order. Steps like \"go back to step 3\" (known as goto statements) are not allowed. **ProceduralThe program lets the programmer give a name to a list of orders, which turns those orders into a \"procedure\" they can use later. Most structured languages are also procedural. * Object- OrientedIdeas are explained to the computer using objects, pieces of code that have a set of orders they can be given and some information about them. == Declarative programming == In declarative paradigms, the programmer tells the computer what to do instead of how to do it. If they wanted the computer to draw a cat face, they might give directions like \"Draw a face, draw two eyes, two ears, and a mouth\". The most well-known declarative paradigms are: *FunctionalMost of the work is done by functions with no side effects. *LogicA set of facts are stated, and then one or more \"questions\" are asked. *Event- drivenPieces of code are set to run when certain things happen (like the computer being turned on). == Other paradigms == Some paradigms can be found in both imperative and declarative languages. These paradigms are usually found with one of the above paradigms instead of going on their own. * Parallel: More than one piece of code is run at the same time. * Meta: Special things in the language let the programmer change the way the language itself acts. == Overview == Programming languages are grouped by paradigms in the same way that machines might be grouped by what they're used for. A few languages fit in just one main paradigm, such as: * Smalltalk (object- oriented) * Assembly (imperative, but not structured or object-oriented) * Haskell (functional) * Prolog (logic) Most languages, though, are in more than one paradigm. Some of the ones that stand out for having more than just one are: * Scala (object-oriented, functional, parallel) * Visual Basic (event- driven, object-oriented) * Common Lisp (procedural, functional, object oriented, meta) * Scheme (functional, procedural, meta) * Perl (functional, procedural, meta, object-oriented, event-driven) * Python (functional, object- oriented, procedural) * Ruby (functional, object-oriented, procedural) * Wolfram Language (functional, procedural, generally declarative) * Oz (logic, functional, imperative, object-oriented) * F# (functional, imperative, object- oriented, meta) Having more paradigms is not always good. One time that having fewer paradigms can be a good thing is when there is a language that is only functional. A function in one of these languages sometimes does less work (like only going over the parts of a group of things it actually needs to) than it might have to if the language was also procedural. Many programming paradigms are as well known for the things they do not let people do as for those they do let people do. One time where this is true is functional languages. When a functional language is only or mostly functional, it usually will not allow side-effects. Another time where this is true is structured programming: it is different from normal imperative languages because it does not let programmers use \"goto statements\" (statements telling the program to go to an earlier step). Because of this and other reasons, people sometimes think new paradigms do not allow enough things. It is sometimes okay for the computer to not let people do things, though: it can help people avoid problems with their code, and let the computer make guesses that so it can run code faster, or even check code for problems before the code runs! == Problems with paradigms == Some people who study programming languages do not like that paradigms are used to group programming languages, such as Harper and Krishnamurthi.. Those people say that a lot of programming languages can't just be grouped into paradigms because languages borrow things and ideas from lots of paradigms. == History == New paradigms have been created over time, and people either pointed them out at the time, or when looking back. One of the first paradigms that was recognized as a new way of programming was structured programming from the 1960s. The idea of a \"programming paradigm\" is from 1978 if not earlier, when Robert W. Floyd used it while teaching. The word \"paradigm\" in the way Robert meant it was first used by Thomas Kuhn in his book, The Structure of Scientific Revolutions (1962). === Machine code === The lowest-level (closest to how the computer likes to understand things) and oldest programming paradigm is machine code, an imperative paradigm. The directions in machine code are just a set of numbers in a certain order. Assembly language is a little bit less low-level (and a little bit less old). In assembly language, the directions for the computer are given mnemonics (easier-to-remember names), and memory addresses (directions to find a piece of information in the computer) can be given names. These are sometimes called first- and second-generation languages. In the 1960s, assembly languages were made better by adding new things like library COPY, macros (bits of \"special\" code that got transformed to normal code before the program started running), running procedures (sets of directions given a name and saved for later), and variables (items given names and saved for later) from outside the program. This let people use some code in more than one project, and not have to worry about with hardware-specific problems (problems that only happen one one kind of computer) thanks to commands (names for directions) like READ/WRITE/GET/PUT. Assembly was, and sometimes still is, used in systems where it is important for the code to be fast, and it is also used a lot in embedded systems because lets the user have exact control of what the machine does. === Procedural languages === In the very late 1960s, people started inventing procedural languages. These third-generation languages (the first few of what we now call high-level languages) had words related to what they were trying to solve. For example, * COmmon Business Oriented Language (COBOL)uses words like file, move and copy. * FORmula TRANslation (FORTRAN)uses mathematical words and symbols ( shapes used in writing and typing). It was developed mostly for science and engineering. * ALGOrithmic Language (ALGOL)made for writing algorithms (sets of steps telling the computer what to do). It uses mathematical words and symbols, just like FORTRAN. * Programming Language One (PL/I)was supposed to be useful to everyone. * Beginners All purpose Symbolic Instruction Code (BASIC)made to help beginners program. * C a programming language meant to do many things. Dennis Ritchie worked on it from 1969 to 1973 at AT&T; Bell Labs. === Object- oriented programming === After many people had started using procedural languages, they invented object-oriented programming languages. In these languages, data and its \"methods\" (ways of manipulating the data) are put in one \"object\". Some programmers, such as Richard Stallman, do not agree that object-oriented languages are better for explaining ideas to a computer than procedural languages. Because object-oriented programming is a paradigm, not a language, people have made object oriented assembly languages like HLA (High Level Assembly). === Declarative paradigms === At the same time, some people were making declarative programming languages. A language that is well known for being declarative is SQL (a language for adding and removing things from tables). ==Related pages== * Mindset * Type system * Turing completeness == References == ==Other websites== *Classification of the principal programming paradigms *How programming paradigms evolve and get adopted? Category:Computer programming",
 "title": "Programming paradigm"
}